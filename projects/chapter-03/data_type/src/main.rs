
fn main() {
    let guess: u32 = "42".parse().expect("Not a number!");    // 数字ではありません！

    // これはエラーが出る。
    // let guess = "42".parse().expect("Not a number!");

    let x = 2.0; // f64

    let y: f32 = 3.0; // f32

    // division
    // 割り算
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0
                         // 結果は0
                         // 整数同士の割り算は、必ず整数になる。
    let floored2 = 2. / 3.; // 小数にしたかったら、式を小数で作る

    println!("floored: {}", floored);
    println!("floored2: {}", floored2);

    let t = true;

    let f: bool = false;

    let c: char = 'z'; // ダブルクォーツだとエラーが出る
    let z = 'ℤ';
    let heart_eyed_cat = '😻';

    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, _) = tup;  // これは分配と呼ばれる手法
    println!("The value of y is {}", y);

    let a = [1, 2, 3, 4, 5];
    // 明示的に型と要素の数を指定できる。
    // [型; 個数]  セミコロンで区切ることに注意
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    let a = [3; 5];  // 3という値が5つあることを示している。
    // let a = [3, 3, 3, 3, 3] と同じ意味

    let first = a[0];
    let second = a[1];
    let panic = a[10];
}

// 各符号付きバリアントは、-(2n - 1)以上2n - 1 - 1以下の数値を保持でき、 ここでnはこのバリアントが使用するビット数。
// i8型は-(27)から27 - 1まで、 つまり、-128から127までを保持できます

// isizeやusizeはコンピューターの種類によって変わる
// 32ビットアーキテクチャなら32ビット
// 64ビットアーキテクチャなら64ビット

// 整数型の基準はi32型
// 浮動小数点型の標準はf64

// 文字列の標準はchar型
// シングルクォートで指定される


// 複合型

// タプルは位置ごとに型がある。全部同じじゃなくてもok

// 配列は全て同じ型でなければならない。さらに固定長。
// ベクタと呼ばれる標準ライブラリは、サイズの伸縮が可能。迷ったらこっち使え。

// プログラムがエラーで終了したことをRustでは"パニック"と呼ぶ
