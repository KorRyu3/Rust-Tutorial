fn main() {
    let mut s1 = String::from("hello");

    let len = calculate_length(&s1);  // 引数に入れた後も変数を使いたいから、参照渡しにする
    // let len = calculate_length(s1);  // これだと、この後`s1`は使えない

    // '{}'の長さは、{}です
    println!("The length of '{}' is {}.", s1, len);

    change(&mut s1);

    let mut s = String::from("hello");

    // 可変な参照は一つしか持てない
    // 可変じゃなければいくらでもok
    let r1 = &mut s;
    // let r2 = &mut s;  // パニック！

    println!("{}", r1);
    // println!("{}, {}", r1, r2);


    let mut s = String::from("hello");

    { // スコープが違うなら、いくらでも作ってok
        let r1 = &mut s;

    } // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

    let r2 = &mut s;


    let mut s3 = String::from("hello");

    let r1 = &s3; // 問題なし (不変は読み込みだけだから)
    let r2 = &s3; // 問題なし
    let r3 = &mut s3; // 大問題！(可変は読み込みと書き込み。上の不変参照たちは、突然値が変わることを予期していない！)

    // println!("{}, {}, {}", r1, r2, r3);


    let reference_to_nothing = dangle();  // ダングリングが起きちゃうからコメントアウト

}

// &が参照の合図
// 関数の引数に参照を取ることを借用と呼びます.
fn calculate_length(s: &String) -> usize { // sはStringへの参照
    s.len()
} // ここで、sはスコープ外になる。けど、参照しているものの所有権を持っているわけではないので
// 何も起こらない


// 参照も標準で不変
// 可変にするなら、変数と同じく`mut`をつける
// `&mut`で、可変な参照を表している
// 可変にしたいなら、関数の引数、実引数、変数定義全てに`mut`をつけなければならない
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

// これはダングリング参照
// fn dangle() -> &String { // dangleはStringへの参照を返す
fn dangle() -> String {

    let s = String::from("hello"); // sは新しいString

    // &s // String sへの参照を返す
    s
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは消される。
  // 危険だ. 無いものを参照しようとしてしまう！


/*
Q. なんで可変な参照は特定のスコープで一つしか持てないの？
A. データの競合が起きてしまう可能性があるから
    - 2つ以上のポインタが同じデータに同時にアクセスする。
    - 少なくとも一つのポインタがデータに書き込みを行っている。
    - データへのアクセスを同期する機構が使用されていない。
*/

// Rustは、データ競合が起こるコードをコンパイルさえしないので、この問題が発生しないようにしてくれる!!!
// 安全！


/*
ポインタのある言語では、誤ってダングリングポインタを生成してしまいやすい.
ダングリングポインタとは、 他人に渡されてしまった可能性のあるメモリを指すポインタのことであり、
    その箇所へのポインタを保持している間に、 メモリを解放してしまうことで発生します.
けれど、Rustはコンパイラが参照がダングリング参照にならないことを絶対に保証してくれる.
参照がスコープを抜けるまで、データがスコープを抜けないようにしてくれる.
*/
